diff --git a/hybrid/internal/BUILD.bazel b/hybrid/internal/BUILD.bazel
index f9c013789..a8ed8016a 100644
--- a/hybrid/internal/BUILD.bazel
+++ b/hybrid/internal/BUILD.bazel
@@ -2,6 +2,43 @@ package(default_visibility = ["//:__subpackages__"])
 
 licenses(["notice"])
 
+cc_library(
+    name = "hpke_context",
+    srcs = ["hpke_context.cc"],
+    hdrs = ["hpke_context.h"],
+    include_prefix = "tink/hybrid/internal",
+    tags = ["requires_boringcrypto_update"],
+    visibility = ["//visibility:public"],
+    deps = [
+        ":hpke_context_boringssl",
+        ":hpke_util",
+        "//util:secret_data",
+        "//util:status",
+        "//util:statusor",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
+cc_library(
+    name = "hpke_context_boringssl",
+    srcs = ["hpke_context_boringssl.cc"],
+    hdrs = ["hpke_context_boringssl.h"],
+    include_prefix = "tink/hybrid/internal",
+    tags = ["requires_boringcrypto_update"],
+    deps = [
+        ":hpke_util",
+        ":hpke_util_boringssl",
+        "//internal:ssl_unique_ptr",
+        "//subtle:subtle_util",
+        "//util:secret_data",
+        "//util:status",
+        "//util:statusor",
+        "@boringssl//:crypto",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
 cc_library(
     name = "hpke_decrypt",
     srcs = ["hpke_decrypt.cc"],
@@ -164,10 +201,12 @@ cc_library(
 
 cc_library(
     name = "hpke_test_util",
+    testonly = 1,
     srcs = ["hpke_test_util.cc"],
     hdrs = ["hpke_test_util.h"],
     include_prefix = "tink/hybrid/internal",
     deps = [
+        ":hpke_util",
         "//proto:hpke_cc_proto",
         "//util:status",
         "//util:statusor",
@@ -176,6 +215,12 @@ cc_library(
     ],
 )
 
+cc_library(
+    name = "hpke_util",
+    hdrs = ["hpke_util.h"],
+    include_prefix = "tink/hybrid/internal",
+)
+
 cc_library(
     name = "hpke_util_boringssl",
     srcs = ["hpke_util_boringssl.cc"],
@@ -183,6 +228,7 @@ cc_library(
     include_prefix = "tink/hybrid/internal",
     tags = ["requires_boringcrypto_update"],
     deps = [
+        ":hpke_util",
         "//proto:hpke_cc_proto",
         "//util:status",
         "//util:statusor",
@@ -192,8 +238,51 @@ cc_library(
     ],
 )
 
+cc_library(
+    name = "test_hpke_context_boringssl",
+    testonly = 1,
+    srcs = ["test_hpke_context_boringssl.cc"],
+    hdrs = ["test_hpke_context_boringssl.h"],
+    include_prefix = "tink/hybrid/internal",
+    tags = ["requires_boringcrypto_update"],
+    deps = [
+        ":hpke_context_boringssl",
+        ":hpke_util",
+        ":hpke_util_boringssl",
+        "//internal:ssl_unique_ptr",
+        "//subtle:subtle_util",
+        "//util:secret_data",
+        "//util:status",
+        "//util:statusor",
+        "@boringssl//:crypto",
+        "@com_google_absl//absl/strings",
+    ],
+)
+
 # tests
 
+cc_test(
+    name = "hpke_context_boringssl_test",
+    size = "small",
+    srcs = ["hpke_context_boringssl_test.cc"],
+    tags = ["requires_boringcrypto_update"],
+    deps = [
+        ":hpke_context_boringssl",
+        ":hpke_test_util",
+        ":hpke_util",
+        ":test_hpke_context_boringssl",
+        "//proto:hpke_cc_proto",
+        "//util:secret_data",
+        "//util:status",
+        "//util:test_matchers",
+        "//util:test_util",
+        "@boringssl//:crypto",
+        "@com_google_absl//absl/status",
+        "@com_google_absl//absl/strings",
+        "@com_google_googletest//:gtest_main",
+    ],
+)
+
 cc_test(
     name = "hpke_decrypt_boringssl_test",
     size = "small",
@@ -345,6 +434,7 @@ cc_test(
     tags = ["requires_boringcrypto_update"],
     deps = [
         ":hpke_test_util",
+        ":hpke_util",
         ":hpke_util_boringssl",
         "//proto:hpke_cc_proto",
         "//util:test_matchers",
@@ -353,4 +443,3 @@ cc_test(
         "@com_google_googletest//:gtest_main",
     ],
 )
-#include "third_party/absl/status/status.h"
diff --git a/hybrid/internal/CMakeLists.txt b/hybrid/internal/CMakeLists.txt
index eac9c34cc..00132a360 100644
--- a/hybrid/internal/CMakeLists.txt
+++ b/hybrid/internal/CMakeLists.txt
@@ -1,5 +1,41 @@
 tink_module(hybrid::internal)
 
+tink_cc_library(
+  NAME hpke_context
+  SRCS
+    hpke_context.cc
+    hpke_context.h
+  DEPS
+    tink::hybrid::internal::hpke_context_boringssl
+    tink::hybrid::internal::hpke_util
+    absl::status
+    absl::strings
+    tink::util::secret_data
+    tink::util::status
+    tink::util::statusor
+  TAGS
+    exclude_if_openssl
+)
+
+tink_cc_library(
+  NAME hpke_context_boringssl
+  SRCS
+    hpke_context_boringssl.cc
+    hpke_context_boringssl.h
+  DEPS
+    tink::hybrid::internal::hpke_util
+    tink::hybrid::internal::hpke_util_boringssl
+    absl::strings
+    crypto
+    tink::internal::ssl_unique_ptr
+    tink::subtle::subtle_util
+    tink::util::secret_data
+    tink::util::status
+    tink::util::statusor
+  TAGS
+    exclude_if_openssl
+)
+
 tink_cc_library(
   NAME hpke_decrypt
   SRCS
@@ -158,6 +194,7 @@ tink_cc_library(
     hpke_test_util.cc
     hpke_test_util.h
   DEPS
+    tink::hybrid::internal::hpke_util
     absl::status
     absl::strings
     tink::util::status
@@ -167,12 +204,21 @@ tink_cc_library(
     exclude_if_openssl
 )
 
+tink_cc_library(
+  NAME hpke_util
+  SRCS
+    hpke_util.h
+  TAGS
+    exclude_if_openssl
+)
+
 tink_cc_library(
   NAME hpke_util_boringssl
   SRCS
     hpke_util_boringssl.cc
     hpke_util_boringssl.h
   DEPS
+    tink::hybrid::internal::hpke_util
     absl::status
     absl::strings
     crypto
@@ -336,6 +382,7 @@ tink_cc_test(
     hpke_util_boringssl_test.cc
   DEPS
     tink::hybrid::internal::hpke_test_util
+    tink::hybrid::internal::hpke_util
     tink::hybrid::internal::hpke_util_boringssl
     gmock
     crypto
diff --git a/hybrid/internal/hpke_context.cc b/hybrid/internal/hpke_context.cc
new file mode 100644
index 000000000..e0d5675cb
--- /dev/null
+++ b/hybrid/internal/hpke_context.cc
@@ -0,0 +1,91 @@
+// Copyright 2022 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "tink/hybrid/internal/hpke_context.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "absl/status/status.h"
+#include "absl/strings/string_view.h"
+#include "tink/hybrid/internal/hpke_context_boringssl.h"
+#include "tink/util/secret_data.h"
+#include "tink/util/status.h"
+#include "tink/util/statusor.h"
+
+namespace crypto {
+namespace tink {
+namespace internal {
+
+constexpr int kX25519KemEncodingLengthInBytes = 32;
+
+std::string ConcatenatePayload(absl::string_view encapsulated_key,
+                               absl::string_view ciphertext) {
+  return absl::StrCat(encapsulated_key, ciphertext);
+}
+
+util::StatusOr<HpkePayloadView> SplitPayload(const HpkeKem& kem,
+                                             absl::string_view payload) {
+  if (kem == HpkeKem::kX25519HkdfSha256) {
+    return HpkePayloadView(payload.substr(0, kX25519KemEncodingLengthInBytes),
+                           payload.substr(kX25519KemEncodingLengthInBytes));
+  }
+  return util::Status(
+      absl::StatusCode::kInvalidArgument,
+      absl::StrCat("Unable to split HPKE payload for KEM type ", kem));
+}
+
+util::StatusOr<std::unique_ptr<HpkeContext>> HpkeContext::SetupSender(
+    const HpkeParams& params, absl::string_view recipient_public_key,
+    absl::string_view info) {
+  if (recipient_public_key.empty()) {
+    return util::Status(absl::StatusCode::kInvalidArgument,
+                        "Recipient public key is empty.");
+  }
+  util::StatusOr<SenderHpkeContextBoringSsl> sender_context =
+      HpkeContextBoringSsl::SetupSender(params, recipient_public_key, info);
+  if (!sender_context.ok()) {
+    return sender_context.status();
+  }
+  return {absl::WrapUnique(new HpkeContext(
+      sender_context->encapsulated_key, std::move(sender_context->context)))};
+}
+
+util::StatusOr<std::unique_ptr<HpkeContext>> HpkeContext::SetupRecipient(
+    const HpkeParams& params, const util::SecretData& recipient_private_key,
+    absl::string_view encapsulated_key, absl::string_view info) {
+  if (recipient_private_key.empty()) {
+    return util::Status(absl::StatusCode::kInvalidArgument,
+                        "Recipient private key is empty.");
+  }
+  if (encapsulated_key.empty()) {
+    return util::Status(absl::StatusCode::kInvalidArgument,
+                        "Encapsulated key is empty.");
+  }
+  util::StatusOr<std::unique_ptr<HpkeContextBoringSsl>> context =
+      HpkeContextBoringSsl::SetupRecipient(params, recipient_private_key,
+                                           encapsulated_key, info);
+  if (!context.ok()) {
+    return context.status();
+  }
+  return {absl::WrapUnique(
+      new HpkeContext(encapsulated_key, *std::move(context)))};
+}
+
+}  // namespace internal
+}  // namespace tink
+}  // namespace crypto
diff --git a/hybrid/internal/hpke_context.h b/hybrid/internal/hpke_context.h
new file mode 100644
index 000000000..e6bddc636
--- /dev/null
+++ b/hybrid/internal/hpke_context.h
@@ -0,0 +1,123 @@
+// Copyright 2022 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_H_
+#define THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "absl/strings/string_view.h"
+#include "tink/hybrid/internal/hpke_context_boringssl.h"
+#include "tink/hybrid/internal/hpke_util.h"
+#include "tink/util/secret_data.h"
+#include "tink/util/statusor.h"
+
+namespace crypto {
+namespace tink {
+namespace internal {
+
+// Pair of string views for an HPKE payload (encapsulated key and ciphertext).
+struct HpkePayloadView {
+  HpkePayloadView(absl::string_view encapsulated_key,
+                  absl::string_view ciphertext)
+      : encapsulated_key(encapsulated_key), ciphertext(ciphertext) {}
+
+  absl::string_view encapsulated_key;
+  absl::string_view ciphertext;
+};
+
+// Creates HPKE payload `encapsulated_key` || `ciphertext` (i.e., Tink hybrid
+// encryption wire format described at
+// https://developers.google.com/tink/wire-format#hybrid_encryption).
+std::string ConcatenatePayload(absl::string_view encapsulated_key,
+                               absl::string_view ciphertext);
+
+// Splits `payload` into an `HpkePayloadView` struct.  The `kem` parameter is
+// used to determine how to split the payload.
+//
+// WARNING: The string pointed to by `payload` must outlive the returned object.
+crypto::tink::util::StatusOr<HpkePayloadView> SplitPayload(
+    const HpkeKem& kem, absl::string_view payload);
+
+// Represents an HPKE context for either a sender or a recipient.
+class HpkeContext {
+ public:
+  // Sets up an HPKE sender context.  Returns an error if initialization
+  // fails.  Otherwise, returns a unique pointer to the sender context.
+  //
+  //   `params`: HPKE parameters (KEM, KDF, and AEAD).
+  //   `recipient_public_key`: KEM-encoding of recipient public key.
+  //   `info`: Application-specific context for key derivation.
+  static crypto::tink::util::StatusOr<std::unique_ptr<HpkeContext>> SetupSender(
+      const HpkeParams& params, absl::string_view recipient_public_key,
+      absl::string_view info);
+
+  // Sets up an HPKE recipient context.  Returns an error if initialization
+  // fails.  Otherwise, returns a unique pointer to the recipient context.
+  //
+  //   `params`: HPKE parameters (KEM, KDF, and AEAD).
+  //   `recipient_private_key`: Recipient private key.
+  //   `encapsulated_key`: Encapsulated key.
+  //   `info`: Application-specific context for key derivation.
+  static crypto::tink::util::StatusOr<std::unique_ptr<HpkeContext>>
+  SetupRecipient(const HpkeParams& params,
+                 const util::SecretData& recipient_private_key,
+                 absl::string_view encapsulated_key, absl::string_view info);
+
+  absl::string_view EncapsulatedKey() const {
+    return encapsulated_key_;
+  }
+
+  // Performs an AEAD encryption of `plaintext` with `associated_data`. Returns
+  // an error if encryption fails.  Otherwise, returns the ciphertext.
+  crypto::tink::util::StatusOr<std::string> Seal(
+      absl::string_view plaintext, absl::string_view associated_data) {
+    return context_->Seal(plaintext, associated_data);
+  }
+
+  // Performs an AEAD decryption of `ciphertext` with `associated_data`. Returns
+  // an error if decryption fails.  Otherwise, returns the plaintext.
+  crypto::tink::util::StatusOr<std::string> Open(
+      absl::string_view ciphertext, absl::string_view associated_data) {
+    return context_->Open(ciphertext, associated_data);
+  }
+
+  // Exports `secret_length` bytes of secret material using `exporter_context`
+  // for the input context.  Returns an error if export fails.  Otherwise,
+  // returns a secret of the requested length.
+  crypto::tink::util::StatusOr<util::SecretData> Export(
+      absl::string_view exporter_context, size_t secret_length) {
+    return context_->Export(exporter_context, secret_length);
+  }
+
+ private:
+  explicit HpkeContext(absl::string_view encapsulated_key,
+                       std::unique_ptr<HpkeContextBoringSsl> context)
+      : encapsulated_key_(encapsulated_key), context_(std::move(context)) {}
+
+  const std::string encapsulated_key_;
+  const std::unique_ptr<HpkeContextBoringSsl> context_;
+};
+
+}  // namespace internal
+}  // namespace tink
+}  // namespace crypto
+
+#endif  // THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_H_
diff --git a/hybrid/internal/hpke_context_boringssl.cc b/hybrid/internal/hpke_context_boringssl.cc
new file mode 100644
index 000000000..47a51ed16
--- /dev/null
+++ b/hybrid/internal/hpke_context_boringssl.cc
@@ -0,0 +1,167 @@
+// Copyright 2022 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#include "tink/hybrid/internal/hpke_context_boringssl.h"
+
+#include <string>
+#include <utility>
+
+#include "absl/strings/string_view.h"
+#include "openssl/base.h"
+#include "openssl/hpke.h"
+#include "tink/hybrid/internal/hpke_util.h"
+#include "tink/hybrid/internal/hpke_util_boringssl.h"
+#include "tink/internal/ssl_unique_ptr.h"
+#include "tink/subtle/subtle_util.h"
+#include "tink/util/secret_data.h"
+#include "tink/util/statusor.h"
+
+namespace crypto {
+namespace tink {
+namespace internal {
+
+util::StatusOr<SenderHpkeContextBoringSsl>
+HpkeContextBoringSsl::SetupSender(const HpkeParams& params,
+                                  absl::string_view recipient_public_key,
+                                  absl::string_view context_info) {
+  util::StatusOr<const EVP_HPKE_KEM *> kem = KemParam(params);
+  if (!kem.ok()) {
+    return kem.status();
+  }
+  util::StatusOr<const EVP_HPKE_KDF *> kdf = KdfParam(params);
+  if (!kdf.ok()) {
+    return kdf.status();
+  }
+  util::StatusOr<const EVP_HPKE_AEAD *> aead = AeadParam(params);
+  if (!aead.ok()) {
+    return aead.status();
+  }
+  uint8_t enc[EVP_HPKE_MAX_ENC_LENGTH];
+  size_t enc_len;
+  SslUniquePtr<EVP_HPKE_CTX> context(EVP_HPKE_CTX_new());
+  if (!EVP_HPKE_CTX_setup_sender(
+          context.get(), enc, &enc_len, sizeof(enc), *kem, *kdf, *aead,
+          reinterpret_cast<const uint8_t *>(recipient_public_key.data()),
+          recipient_public_key.size(),
+          reinterpret_cast<const uint8_t *>(context_info.data()),
+          context_info.size())) {
+    return util::Status(absl::StatusCode::kUnknown,
+                        "Unable to set up HPKE sender context.");
+  }
+  SenderHpkeContextBoringSsl tuple;
+  tuple.context =
+      absl::WrapUnique(new HpkeContextBoringSsl(std::move(context)));
+  tuple.encapsulated_key =
+      std::string(reinterpret_cast<const char *>(enc), enc_len);
+  return std::move(tuple);
+}
+
+util::StatusOr<std::unique_ptr<HpkeContextBoringSsl>>
+HpkeContextBoringSsl::SetupRecipient(
+    const HpkeParams& params, const util::SecretData& recipient_private_key,
+    absl::string_view encapsulated_key, absl::string_view info) {
+  util::StatusOr<const EVP_HPKE_KEM *> kem = KemParam(params);
+  if (!kem.ok()) {
+    return kem.status();
+  }
+  util::StatusOr<const EVP_HPKE_KDF *> kdf = KdfParam(params);
+  if (!kdf.ok()) {
+    return kdf.status();
+  }
+  util::StatusOr<const EVP_HPKE_AEAD *> aead = AeadParam(params);
+  if (!aead.ok()) {
+    return aead.status();
+  }
+  bssl::ScopedEVP_HPKE_KEY hpke_key;
+  if (!EVP_HPKE_KEY_init(
+          hpke_key.get(), *kem,
+          reinterpret_cast<const uint8_t *>(recipient_private_key.data()),
+          recipient_private_key.size())) {
+    return util::Status(
+        absl::StatusCode::kInvalidArgument,
+        "Unable to initialize BoringSSL HPKE recipient private key.");
+  }
+  SslUniquePtr<EVP_HPKE_CTX> context(EVP_HPKE_CTX_new());
+  if (!EVP_HPKE_CTX_setup_recipient(
+          context.get(), hpke_key.get(), *kdf, *aead,
+          reinterpret_cast<const uint8_t *>(encapsulated_key.data()),
+          encapsulated_key.size(),
+          reinterpret_cast<const uint8_t *>(info.data()), info.size())) {
+    return util::Status(absl::StatusCode::kUnknown,
+                        "Unable to set up BoringSSL HPKE recipient context.");
+  }
+  return absl::WrapUnique(new HpkeContextBoringSsl(std::move(context)));
+}
+
+util::StatusOr<std::string> HpkeContextBoringSsl::Seal(
+    absl::string_view plaintext, absl::string_view associated_data) {
+  std::string ciphertext;
+  subtle::ResizeStringUninitialized(
+      &ciphertext,
+      plaintext.size() + EVP_HPKE_CTX_max_overhead(context_.get()));
+  size_t max_out_len = ciphertext.size();
+  size_t ciphertext_size;
+  if (!EVP_HPKE_CTX_seal(
+          context_.get(), reinterpret_cast<uint8_t *>(&ciphertext[0]),
+          &ciphertext_size, max_out_len,
+          reinterpret_cast<const uint8_t *>(plaintext.data()), plaintext.size(),
+          reinterpret_cast<const uint8_t *>(associated_data.data()),
+          associated_data.size())) {
+    return util::Status(absl::StatusCode::kUnknown,
+                        "BoringSSL HPKE encryption failed.");
+  }
+  if (ciphertext_size < ciphertext.size()) {
+    subtle::ResizeStringUninitialized(&ciphertext, ciphertext_size);
+  }
+  return ciphertext;
+}
+
+util::StatusOr<std::string> HpkeContextBoringSsl::Open(
+    absl::string_view ciphertext, absl::string_view associated_data) {
+  std::string plaintext;
+  subtle::ResizeStringUninitialized(&plaintext, ciphertext.size());
+  size_t plaintext_size;
+  if (!EVP_HPKE_CTX_open(
+          context_.get(), reinterpret_cast<uint8_t *>(&plaintext[0]),
+          &plaintext_size, plaintext.size(),
+          reinterpret_cast<const uint8_t *>(ciphertext.data()),
+          ciphertext.size(),
+          reinterpret_cast<const uint8_t *>(associated_data.data()),
+          associated_data.size())) {
+    return util::Status(absl::StatusCode::kUnknown,
+                        "BoringSSL HPKE decryption failed.");
+  }
+  subtle::ResizeStringUninitialized(&plaintext, plaintext_size);
+  return plaintext;
+}
+
+util::StatusOr<util::SecretData> HpkeContextBoringSsl::Export(
+    absl::string_view exporter_context, int64_t secret_length) {
+  std::string secret;
+  subtle::ResizeStringUninitialized(&secret, secret_length);
+  if (!EVP_HPKE_CTX_export(
+          context_.get(), reinterpret_cast<uint8_t *>(&secret[0]),
+          secret_length,
+          reinterpret_cast<const uint8_t *>(exporter_context.data()),
+          exporter_context.size())) {
+    return util::Status(absl::StatusCode::kUnknown, "Unable to export secret.");
+  }
+  return util::SecretDataFromStringView(secret);
+}
+
+}  // namespace internal
+}  // namespace tink
+}  // namespace crypto
diff --git a/hybrid/internal/hpke_context_boringssl.h b/hybrid/internal/hpke_context_boringssl.h
new file mode 100644
index 000000000..cb136b61a
--- /dev/null
+++ b/hybrid/internal/hpke_context_boringssl.h
@@ -0,0 +1,97 @@
+// Copyright 2022 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_BORINGSSL_H_
+#define THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_BORINGSSL_H_
+
+#include <stddef.h>
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "absl/strings/string_view.h"
+#include "openssl/base.h"
+#include "openssl/hpke.h"
+#include "tink/hybrid/internal/hpke_util.h"
+#include "tink/internal/ssl_unique_ptr.h"
+#include "tink/util/secret_data.h"
+#include "tink/util/statusor.h"
+
+namespace crypto {
+namespace tink {
+namespace internal {
+
+struct SenderHpkeContextBoringSsl;
+
+class HpkeContextBoringSsl {
+ public:
+  // Sets up an HPKE sender context.  Returns an error if initialization
+  // fails.  Otherwise, returns a unique pointer to the sender context.
+  //
+  //   `params`: HPKE parameters (KEM, KDF, and AEAD).
+  //   `recipient_public_key`: KEM-encoding of recipient public key.
+  //   `info`: Application-specific context for key derivation.
+  static crypto::tink::util::StatusOr<SenderHpkeContextBoringSsl>
+  SetupSender(const HpkeParams& params, absl::string_view recipient_public_key,
+              absl::string_view info);
+
+  // Sets up an HPKE recipient context.  Returns an error if initialization
+  // fails.  Otherwise, returns a unique pointer to the recipient context.
+  //
+  //   `params`: HPKE parameters (KEM, KDF, and AEAD).
+  //   `recipient_private_key`: Recipient private key.
+  //   `encapsulated_key`: Encapsulated key.
+  //   `info`: Application-specific context for key derivation.
+  static crypto::tink::util::StatusOr<std::unique_ptr<HpkeContextBoringSsl>>
+  SetupRecipient(const HpkeParams& params,
+                 const util::SecretData& recipient_private_key,
+                 absl::string_view encapsulated_key, absl::string_view info);
+
+  // Performs an AEAD encryption of `plaintext` with `associated_data`. Returns
+  // an error if encryption fails.  Otherwise, returns the ciphertext.
+  crypto::tink::util::StatusOr<std::string> Seal(
+      absl::string_view plaintext, absl::string_view associated_data);
+
+  // Performs an AEAD decryption of `ciphertext` with `associated_data`. Returns
+  // an error if decryption fails.  Otherwise, returns the plaintext.
+  crypto::tink::util::StatusOr<std::string> Open(
+      absl::string_view ciphertext, absl::string_view associated_data);
+
+  // Exports `secret_length` bytes of secret material using `exporter_context`
+  // for the input context.  Returns an error if export fails.  Otherwise,
+  // returns a secret of the requested length.
+  crypto::tink::util::StatusOr<util::SecretData> Export(
+      absl::string_view exporter_context, int64_t secret_length);
+
+ protected:
+  explicit HpkeContextBoringSsl(SslUniquePtr<EVP_HPKE_CTX> context)
+      : context_(std::move(context)) {}
+
+ private:
+  SslUniquePtr<EVP_HPKE_CTX> context_;
+};
+
+struct SenderHpkeContextBoringSsl {
+  std::unique_ptr<HpkeContextBoringSsl> context;
+  std::string encapsulated_key;
+};
+
+}  // namespace internal
+}  // namespace tink
+}  // namespace crypto
+
+#endif  // THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_CONTEXT_BORINGSSL_H_
diff --git a/hybrid/internal/hpke_decrypt_boringssl.cc b/hybrid/internal/hpke_decrypt_boringssl.cc
index d865aa874..524babcc4 100644
--- a/hybrid/internal/hpke_decrypt_boringssl.cc
+++ b/hybrid/internal/hpke_decrypt_boringssl.cc
@@ -34,8 +34,6 @@ namespace crypto {
 namespace tink {
 namespace internal {
 
-using ::google::crypto::tink::HpkeParams;
-
 util::StatusOr<std::unique_ptr<HpkeDecryptBoringSsl>> HpkeDecryptBoringSsl::New(
     const google::crypto::tink::HpkeParams& params,
     const HpkeKeyBoringSsl& hpke_key, absl::string_view encapsulated_key,
@@ -49,10 +47,10 @@ util::StatusOr<std::unique_ptr<HpkeDecryptBoringSsl>> HpkeDecryptBoringSsl::New(
   return std::move(hpke_decrypt);
 }
 
-util::Status HpkeDecryptBoringSsl::Init(const HpkeParams& params,
-                                        const HpkeKeyBoringSsl& hpke_key,
-                                        absl::string_view encapsulated_key,
-                                        absl::string_view context_info) {
+util::Status HpkeDecryptBoringSsl::Init(
+    const google::crypto::tink::HpkeParams& params,
+    const HpkeKeyBoringSsl& hpke_key, absl::string_view encapsulated_key,
+    absl::string_view context_info) {
   util::StatusOr<const EVP_HPKE_KEM *> kem = KemParam(params);
   if (!kem.ok()) {
     return kem.status();
@@ -105,4 +103,4 @@ util::StatusOr<std::string> HpkeDecryptBoringSsl::Decrypt(
 
 }  // namespace internal
 }  // namespace tink
-}  // namespace crypto
+}  // namespace crypto
diff --git a/hybrid/internal/hpke_encrypt_boringssl.cc b/hybrid/internal/hpke_encrypt_boringssl.cc
index d81f303f9..ec7a010b5 100644
--- a/hybrid/internal/hpke_encrypt_boringssl.cc
+++ b/hybrid/internal/hpke_encrypt_boringssl.cc
@@ -35,8 +35,6 @@ namespace crypto {
 namespace tink {
 namespace internal {
 
-using ::google::crypto::tink::HpkeParams;
-
 util::StatusOr<std::unique_ptr<HpkeEncryptBoringSsl>> HpkeEncryptBoringSsl::New(
     const google::crypto::tink::HpkeParams& params,
     absl::string_view recipient_public_key, absl::string_view context_info) {
diff --git a/hybrid/internal/hpke_key_boringssl.cc b/hybrid/internal/hpke_key_boringssl.cc
index a7b4d6363..d51301fb5 100644
--- a/hybrid/internal/hpke_key_boringssl.cc
+++ b/hybrid/internal/hpke_key_boringssl.cc
@@ -30,11 +30,10 @@
 namespace crypto {
 namespace tink {
 namespace internal {
-
-using ::google::crypto::tink::HpkeKem;
-
+  
 util::StatusOr<std::unique_ptr<HpkeKeyBoringSsl>> HpkeKeyBoringSsl::New(
-    const HpkeKem& kem, absl::string_view recipient_private_key) {
+    const google::crypto::tink::HpkeKem& kem,
+    absl::string_view recipient_private_key) {
   std::unique_ptr<HpkeKeyBoringSsl> hpke_key =
       absl::WrapUnique(new HpkeKeyBoringSsl(kem));
   util::Status status = hpke_key->Init(recipient_private_key);
diff --git a/hybrid/internal/hpke_test_util.cc b/hybrid/internal/hpke_test_util.cc
index 08895e027..2266228d5 100644
--- a/hybrid/internal/hpke_test_util.cc
+++ b/hybrid/internal/hpke_test_util.cc
@@ -19,6 +19,7 @@
 #include <string>
 
 #include "absl/status/status.h"
+#include "tink/hybrid/internal/hpke_util.h"
 #include "tink/util/status.h"
 #include "proto/hpke.pb.h"
 
@@ -26,13 +27,6 @@ namespace crypto {
 namespace tink {
 namespace internal {
 
-using ::google::crypto::tink::HpkeAead;
-using ::google::crypto::tink::HpkeKdf;
-using ::google::crypto::tink::HpkeKem;
-using ::google::crypto::tink::HpkeParams;
-using ::google::crypto::tink::HpkePrivateKey;
-using ::google::crypto::tink::HpkePublicKey;
-
 // Test vector from https://www.rfc-editor.org/rfc/rfc9180.html#appendix-A.1.
 // DHKEM(X25519, HKDF-SHA256), HKDF-SHA256, AES-128-GCM
 const absl::string_view kTestX25519HkdfSha256Aes128Gcm[] = {
@@ -80,23 +74,24 @@ HpkeTestParams DefaultHpkeTestParams() {
   return HpkeTestParams(kTestX25519HkdfSha256Aes128Gcm);
 }
 
-util::StatusOr<HpkeTestParams> CreateHpkeTestParams(const HpkeParams& params) {
-  if (params.kem() != HpkeKem::DHKEM_X25519_HKDF_SHA256) {
+util::StatusOr<HpkeTestParams> CreateHpkeTestParams(
+    const google::crypto::tink::HpkeParams& params) {
+  if (params.kem() != google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256) {
     return util::Status(
         absl::StatusCode::kInvalidArgument,
         absl::StrCat("No test parameters for specified KEM:", params.kem()));
   }
-  if (params.kdf() != HpkeKdf::HKDF_SHA256) {
+  if (params.kdf() != google::crypto::tink::HpkeKdf::HKDF_SHA256) {
     return util::Status(
         absl::StatusCode::kInvalidArgument,
         absl::StrCat("No test parameters for specified KDF:", params.kdf()));
   }
   switch (params.aead()) {
-    case HpkeAead::AES_128_GCM:
+    case google::crypto::tink::HpkeAead::AES_128_GCM:
       return HpkeTestParams(kTestX25519HkdfSha256Aes128Gcm);
-    case HpkeAead::AES_256_GCM:
+    case google::crypto::tink::HpkeAead::AES_256_GCM:
       return HpkeTestParams(kTestX25519HkdfSha256Aes256Gcm);
-    case HpkeAead::CHACHA20_POLY1305:
+    case google::crypto::tink::HpkeAead::CHACHA20_POLY1305:
       return HpkeTestParams(kTestX25519HkdfSha256ChaCha20Poly1305);
     default:
       return util::Status(absl::StatusCode::kInvalidArgument,
@@ -105,30 +100,60 @@ util::StatusOr<HpkeTestParams> CreateHpkeTestParams(const HpkeParams& params) {
   }
 }
 
-HpkeParams CreateHpkeParams(const HpkeKem& kem, const HpkeKdf& kdf,
-                            const HpkeAead& aead) {
-  HpkeParams params;
+util::StatusOr<HpkeTestParams> CreateHpkeTestParams(const HpkeParams& params) {
+  if (params.kem != HpkeKem::kX25519HkdfSha256) {
+    return util::Status(
+        absl::StatusCode::kInvalidArgument,
+        absl::StrCat("No test parameters for specified KEM:", params.kem));
+  }
+  if (params.kdf != HpkeKdf::kHkdfSha256) {
+    return util::Status(
+        absl::StatusCode::kInvalidArgument,
+        absl::StrCat("No test parameters for specified KDF:", params.kdf));
+  }
+  switch (params.aead) {
+    case HpkeAead::kAes128Gcm:
+      return HpkeTestParams(kTestX25519HkdfSha256Aes128Gcm);
+    case HpkeAead::kAes256Gcm:
+      return HpkeTestParams(kTestX25519HkdfSha256Aes256Gcm);
+    case HpkeAead::kChaCha20Poly1305:
+      return HpkeTestParams(kTestX25519HkdfSha256ChaCha20Poly1305);
+    default:
+      return util::Status(
+          absl::StatusCode::kInvalidArgument,
+          absl::StrCat("No test parameters for specified AEAD:", params.aead));
+  }
+}
+
+google::crypto::tink::HpkeParams CreateHpkeParams(
+    const google::crypto::tink::HpkeKem& kem,
+    const google::crypto::tink::HpkeKdf& kdf,
+    const google::crypto::tink::HpkeAead& aead) {
+  google::crypto::tink::HpkeParams params;
   params.set_kem(kem);
   params.set_kdf(kdf);
   params.set_aead(aead);
   return params;
 }
 
-HpkePublicKey CreateHpkePublicKey(const HpkeParams& params,
-                                  const std::string& raw_key_bytes) {
-  HpkePublicKey key_proto;
+google::crypto::tink::HpkePublicKey CreateHpkePublicKey(
+    const google::crypto::tink::HpkeParams& params,
+    const std::string& raw_key_bytes) {
+  google::crypto::tink::HpkePublicKey key_proto;
   key_proto.set_version(0);
   key_proto.set_public_key(raw_key_bytes);
   *key_proto.mutable_params() = params;
   return key_proto;
 }
 
-HpkePrivateKey CreateHpkePrivateKey(const HpkeParams& params,
-                                    const std::string& raw_key_bytes) {
-  HpkePrivateKey private_key_proto;
+google::crypto::tink::HpkePrivateKey CreateHpkePrivateKey(
+    const google::crypto::tink::HpkeParams& params,
+    const std::string& raw_key_bytes) {
+  google::crypto::tink::HpkePrivateKey private_key_proto;
   private_key_proto.set_version(0);
   private_key_proto.set_private_key(raw_key_bytes);
-  HpkePublicKey* public_key_proto = private_key_proto.mutable_public_key();
+  google::crypto::tink::HpkePublicKey* public_key_proto =
+      private_key_proto.mutable_public_key();
   *public_key_proto->mutable_params() = params;
   return private_key_proto;
 }
diff --git a/hybrid/internal/hpke_test_util.h b/hybrid/internal/hpke_test_util.h
index fc3e7dd59..ffd7ca8e4 100644
--- a/hybrid/internal/hpke_test_util.h
+++ b/hybrid/internal/hpke_test_util.h
@@ -20,6 +20,7 @@
 #include <string>
 
 #include "absl/strings/escaping.h"
+#include "tink/hybrid/internal/hpke_util.h"
 #include "tink/util/statusor.h"
 #include "proto/hpke.pb.h"
 
@@ -56,6 +57,10 @@ HpkeTestParams DefaultHpkeTestParams();
 util::StatusOr<HpkeTestParams> CreateHpkeTestParams(
     const google::crypto::tink::HpkeParams& params);
 
+// Creates an HpkeTestParams struct for the specified HpkeParams struct.
+util::StatusOr<HpkeTestParams> CreateHpkeTestParams(
+    const HpkeParams& params);
+
 // Creates an HpkeParams protobuf from `kem`, `kdf`, and `aead`.
 google::crypto::tink::HpkeParams CreateHpkeParams(
     const google::crypto::tink::HpkeKem& kem,
diff --git a/hybrid/internal/hpke_util.h b/hybrid/internal/hpke_util.h
new file mode 100644
index 000000000..bc290b631
--- /dev/null
+++ b/hybrid/internal/hpke_util.h
@@ -0,0 +1,54 @@
+// Copyright 2022 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_UTIL_H_
+#define THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_UTIL_H_
+
+namespace crypto {
+namespace tink {
+namespace internal {
+
+// Values from https://www.rfc-editor.org/rfc/rfc9180.html#section-7.1.
+enum class HpkeKem {
+  kUnknownKem = 0x0,
+  kX25519HkdfSha256 = 0x20,
+};
+
+// Values from https://www.rfc-editor.org/rfc/rfc9180.html#section-7.2.
+enum class HpkeKdf {
+  kUnknownKdf = 0x0,
+  kHkdfSha256 = 0x1,
+};
+
+// Values from https://www.rfc-editor.org/rfc/rfc9180.html#section-7.3.
+enum class HpkeAead {
+  kUnknownAead = 0x0,
+  kAes128Gcm = 0x1,
+  kAes256Gcm = 0x2,
+  kChaCha20Poly1305 = 0x3,
+};
+
+struct HpkeParams {
+  HpkeKem kem;
+  HpkeKdf kdf;
+  HpkeAead aead;
+};
+
+}  // namespace internal
+}  // namespace tink
+}  // namespace crypto
+
+#endif  // THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_UTIL_H_
diff --git a/hybrid/internal/hpke_util_boringssl.cc b/hybrid/internal/hpke_util_boringssl.cc
index c067cbd5b..a05d1072a 100644
--- a/hybrid/internal/hpke_util_boringssl.cc
+++ b/hybrid/internal/hpke_util_boringssl.cc
@@ -20,6 +20,7 @@
 #include "absl/strings/str_cat.h"
 #include "openssl/base.h"
 #include "openssl/hpke.h"
+#include "tink/hybrid/internal/hpke_util.h"
 #include "tink/util/status.h"
 #include "tink/util/statusor.h"
 #include "proto/hpke.pb.h"
@@ -28,14 +29,21 @@ namespace crypto {
 namespace tink {
 namespace internal {
 
-using ::google::crypto::tink::HpkeAead;
-using ::google::crypto::tink::HpkeKdf;
-using ::google::crypto::tink::HpkeKem;
-using ::google::crypto::tink::HpkeParams;
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(const HpkeParams& params) {
+  switch (params.kem) {
+    case HpkeKem::kX25519HkdfSha256:
+      return EVP_hpke_x25519_hkdf_sha256();
+    default:
+      return util::Status(
+          absl::StatusCode::kInvalidArgument,
+          absl::StrCat("Unsupported HPKE KEM algorithm: ", params.kem));
+  }
+}
 
-util::StatusOr<const EVP_HPKE_KEM *> KemParam(const HpkeKem& kem) {
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(
+    const google::crypto::tink::HpkeKem& kem) {
   switch (kem) {
-    case HpkeKem::DHKEM_X25519_HKDF_SHA256:
+    case google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256:
       return EVP_hpke_x25519_hkdf_sha256();
     default:
       return util::Status(
@@ -44,13 +52,26 @@ util::StatusOr<const EVP_HPKE_KEM *> KemParam(const HpkeKem& kem) {
   }
 }
 
-util::StatusOr<const EVP_HPKE_KEM *> KemParam(const HpkeParams& params) {
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(
+    const google::crypto::tink::HpkeParams& params) {
   return KemParam(params.kem());
 }
 
-util::StatusOr<const EVP_HPKE_KDF *> KdfParam(const HpkeParams& params) {
+util::StatusOr<const EVP_HPKE_KDF*> KdfParam(const HpkeParams& params) {
+  switch (params.kdf) {
+    case HpkeKdf::kHkdfSha256:
+      return EVP_hpke_hkdf_sha256();
+    default:
+      return util::Status(
+          absl::StatusCode::kInvalidArgument,
+          absl::StrCat("Unsupported HPKE KDF algorithm: ", params.kdf));
+  }
+}
+
+util::StatusOr<const EVP_HPKE_KDF*> KdfParam(
+    const google::crypto::tink::HpkeParams& params) {
   switch (params.kdf()) {
-    case HpkeKdf::HKDF_SHA256:
+    case google::crypto::tink::HpkeKdf::HKDF_SHA256:
       return EVP_hpke_hkdf_sha256();
     default:
       return util::Status(
@@ -59,13 +80,29 @@ util::StatusOr<const EVP_HPKE_KDF *> KdfParam(const HpkeParams& params) {
   }
 }
 
-util::StatusOr<const EVP_HPKE_AEAD *> AeadParam(const HpkeParams& params) {
+util::StatusOr<const EVP_HPKE_AEAD*> AeadParam(const HpkeParams& params) {
+  switch (params.aead) {
+    case HpkeAead::kAes128Gcm:
+      return EVP_hpke_aes_128_gcm();
+    case HpkeAead::kAes256Gcm:
+      return EVP_hpke_aes_256_gcm();
+    case HpkeAead::kChaCha20Poly1305:
+      return EVP_hpke_chacha20_poly1305();
+    default:
+      return util::Status(
+          absl::StatusCode::kInvalidArgument,
+          absl::StrCat("Unsupported HPKE AEAD algorithm: ", params.aead));
+  }
+}
+
+util::StatusOr<const EVP_HPKE_AEAD*> AeadParam(
+    const google::crypto::tink::HpkeParams& params) {
   switch (params.aead()) {
-    case HpkeAead::AES_128_GCM:
+    case google::crypto::tink::HpkeAead::AES_128_GCM:
       return EVP_hpke_aes_128_gcm();
-    case HpkeAead::AES_256_GCM:
+    case google::crypto::tink::HpkeAead::AES_256_GCM:
       return EVP_hpke_aes_256_gcm();
-    case HpkeAead::CHACHA20_POLY1305:
+    case google::crypto::tink::HpkeAead::CHACHA20_POLY1305:
       return EVP_hpke_chacha20_poly1305();
     default:
       return util::Status(
diff --git a/hybrid/internal/hpke_util_boringssl.h b/hybrid/internal/hpke_util_boringssl.h
index ab6f48c75..55402cbc1 100644
--- a/hybrid/internal/hpke_util_boringssl.h
+++ b/hybrid/internal/hpke_util_boringssl.h
@@ -18,6 +18,7 @@
 #define TINK_HYBRID_INTERNAL_HPKE_UTIL_BORINGSSL_H_
 
 #include "openssl/hpke.h"
+#include "tink/hybrid/internal/hpke_util.h"
 #include "tink/util/statusor.h"
 #include "proto/hpke.pb.h"
 
@@ -25,20 +26,26 @@ namespace crypto {
 namespace tink {
 namespace internal {
 
-util::StatusOr<const EVP_HPKE_KEM *> KemParam(
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(
     const google::crypto::tink::HpkeKem& kem);
 
-util::StatusOr<const EVP_HPKE_KEM *> KemParam(
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(const HpkeParams& params);
+
+util::StatusOr<const EVP_HPKE_KEM*> KemParam(
     const google::crypto::tink::HpkeParams& params);
 
-util::StatusOr<const EVP_HPKE_KDF *> KdfParam(
+util::StatusOr<const EVP_HPKE_KDF*> KdfParam(const HpkeParams& params);
+
+util::StatusOr<const EVP_HPKE_KDF*> KdfParam(
     const google::crypto::tink::HpkeParams& params);
 
-util::StatusOr<const EVP_HPKE_AEAD *> AeadParam(
+util::StatusOr<const EVP_HPKE_AEAD*> AeadParam(const HpkeParams& params);
+
+util::StatusOr<const EVP_HPKE_AEAD*> AeadParam(
     const google::crypto::tink::HpkeParams& params);
 
 }  // namespace internal
 }  // namespace tink
 }  // namespace crypto
 
-#endif  // TINK_HYBRID_INTERNAL_HPKE_UTIL_BORINGSSL_H_
+#endif  // THIRD_PARTY_TINK_CC_HYBRID_INTERNAL_HPKE_UTIL_BORINGSSL_H_
diff --git a/hybrid/internal/hpke_util_boringssl_test.cc b/hybrid/internal/hpke_util_boringssl_test.cc
index f3718bb82..317e404bb 100644
--- a/hybrid/internal/hpke_util_boringssl_test.cc
+++ b/hybrid/internal/hpke_util_boringssl_test.cc
@@ -21,6 +21,7 @@
 #include "gtest/gtest.h"
 #include "openssl/base.h"
 #include "openssl/hpke.h"
+#include "tink/hybrid/internal/hpke_util.h"
 #include "tink/hybrid/internal/hpke_test_util.h"
 #include "tink/util/test_matchers.h"
 #include "tink/util/test_util.h"
@@ -32,21 +33,24 @@ namespace internal {
 namespace {
 
 using ::crypto::tink::test::IsOk;
-using ::google::crypto::tink::HpkeAead;
-using ::google::crypto::tink::HpkeKdf;
-using ::google::crypto::tink::HpkeKem;
-using ::google::crypto::tink::HpkeParams;
 using ::testing::Eq;
 using ::testing::Not;
 
-TEST(HpkeUtilBoringSslTest, ValidParams) {
-  HpkeParams params =
-      CreateHpkeParams(HpkeKem::DHKEM_X25519_HKDF_SHA256, HpkeKdf::HKDF_SHA256,
-                       HpkeAead::AES_256_GCM);
+TEST(HpkeUtilBoringSslTest, ValidParamsFromProto) {
+  google::crypto::tink::HpkeParams params =
+      CreateHpkeParams(google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256,
+                       google::crypto::tink::HpkeKdf::HKDF_SHA256,
+                       google::crypto::tink::HpkeAead::AES_256_GCM);
 
-  util::StatusOr<const EVP_HPKE_KEM *> kem = KemParam(params);
-  ASSERT_THAT(kem.status(), IsOk());
-  EXPECT_THAT(EVP_HPKE_KEM_id(*kem),
+  util::StatusOr<const EVP_HPKE_KEM *> kem_from_enum =
+      KemParam(google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256);
+  ASSERT_THAT(kem_from_enum.status(), IsOk());
+  EXPECT_THAT(EVP_HPKE_KEM_id(*kem_from_enum),
+              Eq(EVP_HPKE_DHKEM_X25519_HKDF_SHA256));
+
+  util::StatusOr<const EVP_HPKE_KEM *> kem_from_proto = KemParam(params);
+  ASSERT_THAT(kem_from_proto.status(), IsOk());
+  EXPECT_THAT(EVP_HPKE_KEM_id(*kem_from_proto),
               Eq(EVP_HPKE_DHKEM_X25519_HKDF_SHA256));
 
   util::StatusOr<const EVP_HPKE_KDF *> kdf = KdfParam(params);
@@ -58,27 +62,73 @@ TEST(HpkeUtilBoringSslTest, ValidParams) {
   EXPECT_THAT(EVP_HPKE_AEAD_id(*aead), Eq(EVP_HPKE_AES_256_GCM));
 }
 
-TEST(HpkeUtilBoringSslTest, UnknownKemParam) {
-  HpkeParams params = CreateHpkeParams(
-      HpkeKem::KEM_UNKNOWN, HpkeKdf::HKDF_SHA256, HpkeAead::AES_256_GCM);
+TEST(HpkeUtilBoringSslTest, ValidParamsFromStruct) {
+  HpkeParams params = {HpkeKem::kX25519HkdfSha256, HpkeKdf::kHkdfSha256,
+                       HpkeAead::kAes256Gcm};
+
+  util::StatusOr<const EVP_HPKE_KEM *> kem_from_proto = KemParam(params);
+  ASSERT_THAT(kem_from_proto.status(), IsOk());
+  EXPECT_THAT(EVP_HPKE_KEM_id(*kem_from_proto),
+              Eq(EVP_HPKE_DHKEM_X25519_HKDF_SHA256));
+
+  util::StatusOr<const EVP_HPKE_KDF *> kdf = KdfParam(params);
+  ASSERT_THAT(kdf.status(), IsOk());
+  EXPECT_THAT(EVP_HPKE_KDF_id(*kdf), Eq(EVP_HPKE_HKDF_SHA256));
+
+  util::StatusOr<const EVP_HPKE_AEAD *> aead = AeadParam(params);
+  ASSERT_THAT(aead.status(), IsOk());
+  EXPECT_THAT(EVP_HPKE_AEAD_id(*aead), Eq(EVP_HPKE_AES_256_GCM));
+}
+
+TEST(HpkeUtilBoringSslTest, UnknownKemParamFromProto) {
+  google::crypto::tink::HpkeParams params =
+      CreateHpkeParams(google::crypto::tink::HpkeKem::KEM_UNKNOWN,
+                       google::crypto::tink::HpkeKdf::HKDF_SHA256,
+                       google::crypto::tink::HpkeAead::AES_256_GCM);
   EXPECT_THAT(KemParam(params).status(), Not(IsOk()));
   EXPECT_THAT(KdfParam(params).status(), IsOk());
   EXPECT_THAT(AeadParam(params).status(), IsOk());
 }
 
-TEST(HpkeUtilBoringSslTest, UnknownKdfParam) {
-  HpkeParams params =
-      CreateHpkeParams(HpkeKem::DHKEM_X25519_HKDF_SHA256, HpkeKdf::KDF_UNKNOWN,
-                       HpkeAead::AES_256_GCM);
+TEST(HpkeUtilBoringSslTest, UnknownKemParamFromStruct) {
+  HpkeParams params = {HpkeKem::kUnknownKem, HpkeKdf::kHkdfSha256,
+                       HpkeAead::kAes256Gcm};
+  EXPECT_THAT(KemParam(params).status(), Not(IsOk()));
+  EXPECT_THAT(KdfParam(params).status(), IsOk());
+  EXPECT_THAT(AeadParam(params).status(), IsOk());
+}
+
+TEST(HpkeUtilBoringSslTest, UnknownKdfParamFromProto) {
+  google::crypto::tink::HpkeParams params =
+      CreateHpkeParams(google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256,
+                       google::crypto::tink::HpkeKdf::KDF_UNKNOWN,
+                       google::crypto::tink::HpkeAead::AES_256_GCM);
+  EXPECT_THAT(KemParam(params).status(), IsOk());
+  EXPECT_THAT(KdfParam(params).status(), Not(IsOk()));
+  EXPECT_THAT(AeadParam(params).status(), IsOk());
+}
+
+TEST(HpkeUtilBoringSslTest, UnknownKdfParamFromStruct) {
+  HpkeParams params = {HpkeKem::kX25519HkdfSha256, HpkeKdf::kUnknownKdf,
+                       HpkeAead::kAes256Gcm};
   EXPECT_THAT(KemParam(params).status(), IsOk());
   EXPECT_THAT(KdfParam(params).status(), Not(IsOk()));
   EXPECT_THAT(AeadParam(params).status(), IsOk());
 }
 
-TEST(HpkeUtilBoringSslTest, UnknownAeadParam) {
-  HpkeParams params =
-      CreateHpkeParams(HpkeKem::DHKEM_X25519_HKDF_SHA256, HpkeKdf::HKDF_SHA256,
-                       HpkeAead::AEAD_UNKNOWN);
+TEST(HpkeUtilBoringSslTest, UnknownAeadParamFromProto) {
+  google::crypto::tink::HpkeParams params =
+      CreateHpkeParams(google::crypto::tink::HpkeKem::DHKEM_X25519_HKDF_SHA256,
+                       google::crypto::tink::HpkeKdf::HKDF_SHA256,
+                       google::crypto::tink::HpkeAead::AEAD_UNKNOWN);
+  EXPECT_THAT(KemParam(params).status(), IsOk());
+  EXPECT_THAT(KdfParam(params).status(), IsOk());
+  EXPECT_THAT(AeadParam(params).status(), Not(IsOk()));
+}
+
+TEST(HpkeUtilBoringSslTest, UnknownAeadParamFromStruct) {
+  HpkeParams params = {HpkeKem::kX25519HkdfSha256, HpkeKdf::kHkdfSha256,
+                       HpkeAead::kUnknownAead};
   EXPECT_THAT(KemParam(params).status(), IsOk());
   EXPECT_THAT(KdfParam(params).status(), IsOk());
   EXPECT_THAT(AeadParam(params).status(), Not(IsOk()));
